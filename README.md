
# LolDataBatch
 
 -------------------

**[롤 전적 검색 프로젝트](https://github.com/kyo705/LolSearcher#lolsearcher)** 에 필요한 데이터 수집 및 데이터들의 통계를 위한 배치 프로그램

 프로젝트 생성 계기
-------------------
해당 프로젝트를 생성하게 된 계기는 **[롤 전적 검색 프로젝트](https://github.com/kyo705/LolSearcher#lolsearcher)** 에서 빠르고 정확한 통계 서비스를 제공하기 위해서 만들어졌다.   
롤 전적 검색 프로젝트에서 게임 캐릭터(챔피언)들의 승률, 아이템 승률, 카운터 챔피언 등을 제공하는 서비스가 필요로 했다. 
 그런데 해당 서비스를 만들기 시작할 때 문제가 발생했다. 그것은 바로, 통계 정보를 제공할 때 **속도 문제**였다. 통계 데이터 서비스를 요청할 때마다 집계함수를 이용한 쿼리문을 사용하기엔 집계해야할 데이터가 많아 처리 속도가 현저하게 느리다는 문제점이 있었다. 그래서 해당 문제를 해결하기 위해 통계 데이터 테이블을 따로 만들고 **매일마다** 서비스 이용자들이 적은 시간인 **새벽**에 전날 발생한 게임 데이터들을 **배치 처리**를 통해 통계 테이블에 데이터를 저장했다.   
 또한, 통계 서비스를 제공하기 위해서는 **많은 양**의 게임 매칭 데이터들이 필요했다. 그러나 게임 회사에서 데이터를 제공해주는 방식에서 **제한 상황(2분 동안 최대 100회 요청 가능)** 이 있기 때문에 **주기적**으로 게임 매칭 데이터들을 수집할 필요가 있었다. 그래서 **스케줄러**를 이용해 **2분마다** 게임 서버의 REST API 통신을 통해 데이터를 수집하는 로직을 만들었다.   

프로젝트 깃 브런치
-----------------------------------------
> - **main** — 실제 메인 브런치(완성본)
> - **develop** — 다음 버전을 위한 개발 브런치(테스트용)

프로젝트 커밋 메시지 카테고리
-----------------------------------------
> - [INITIAL] — repository를 생성하고 최초에 파일을 업로드 할 때
> - [ADD] — 신규 파일 추가
> - [UPDATE] — 코드 변경이 일어날때
> - [REFACTOR] — 코드를 리팩토링 했을때
> - [FIX] — 잘못된 링크 정보 변경, 필요한 모듈 추가 및 삭제
> - [REMOVE] — 파일 제거
> - [STYLE] — 디자인 관련 변경사항


 프로젝트 기술 스택
-----------------
> - Java
> - Spring Boot
> - Spring Quartz
> - Spring Batch
> - DBMS 
>   - 실제 서버 환경 : MariaDB
>   - Test 환경 : h2

 프로젝트 구조
-----------------
![image](https://user-images.githubusercontent.com/89891704/194566899-f71a96fe-89db-459f-bed7-0f885511b397.png)

스텝을 두 단계로 나누고 DB에 임시 저장 테이블을 만든 이유
------------------------
champStaticJob(통계 관련 배치 처리 잡)을 두 단계의 스텝으로 나눴는데 첫 번째 스텝에서는 하룻동안 발생한 많은 양의 게임 전적 데이터들을 특정 챔피언, 특정 아이템, 상대 전적의 관점에서 승률을 추출하여 DB에 임시 데이터로 저장하였다.   
두 번째 스텝에서는 임시 저장된 데이터들을 기존 데이터와 합치는 로직으로 구성하였다.   
이렇게 중간에 임시 저장을 한 이유는 데이터의 무결성을 지키기 위해서이다. 처음 게임 전적 데이터들을 통계 데이터로 바꾸는 과정에서 오류가 발생한다면 오류가 발생하기 전의 청크 단위는 이미 DB에 커밋이 된 후이다. 에러가 발생하고 다시 이전 상태로 롤백을 시켜야하는데 만약 미리 기존 통계 데이터에 신규 통계 데이터를 합쳤다면 다시 이전 상태로 롤백하기 쉽지 않다. 그래서 오류가 났을 때 쉽게 롤백하기 위해 임시 저장할 수 있는 테이블을 생성해 저장해놓고 그 과정에서 유효성 검증이 실패한다면 첫 번째 스텝의 리스너를 통해 ExitStatus를 STOP으로 바꾸고 임시 저장 데이터를 삭제만 하면 배치 처리하기 이전 상태가 된다. 이러한 에러 사항에 대응하기 위해 2단계의 스텝을 두고 임시 테이블을 생성하므로 데이터 무결성을 지킬 수 있었다.   
그 과정에서 두 번째 스텝에서는 임시 저장소에 저장된 데이터 종류가 3가지가 되는데 각각의 데이터를 기존 데이터와 합치는 과정은 서로에게 영향을 주지 않기 때문에 병렬 처리를 하는 것이 더 적절하다고 판단되어 Flow를 이용해 해당 3가지 데이터 합치는 스텝을 병렬로 처리할 수 있었다. 


주의 사항
-------------
JpaPagingReader를 사용할 때 패치 조인을 사용하면 안됌. 이유는 내부적으로 paging 처리를 하기 때문에 패치 조인 시 전부 메모리에 올라오고 그 상태에서 페이지 처리를 함. 따라서 메모리 낭비가 됌. 심한 경우 메모리 초과날 수 있음.    
또한 paging Reader를 사용할 때 정렬을 해야함. spring batch는 읽어올 데이터를 chunk 단위로 나눠 reader에서 반복해서 db로 부터 데이터를 조회한다. 반복하는 과정에서 page 단위만큼 잘라서 데이터베이스로부터 읽어오는데 이 때, 정렬 기준이 명확하지 않아 중복된 데이터를 읽어오거나 빠트린 데이터가 존재할 수도 있다. 따라서 paging reader를 사용할 때 반드시 정렬 기준을 명시해야 한다.   



메모장
------------
validator를 이용해 jobparameter의 유효성을 검증함 (defaultJobParametersValidator와 CustomValidator(ChampStaticJobParametersValidator)를 합친 CompositeJobParametersValidator를 사용함)
해당 validator는 JobLauncher가 Job을 실행하기 전에 실행하여 유효성 검증에 실패하면 JobParametersInvalidException을 발생시키도록 설정하였음.   



